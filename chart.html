<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="Content-Script-Type" content="text/javascript">
		<meta http-equiv="Content-Style-Type" content="text/css">
		<title>ITAhM::Chart</title>
		
		<style>
body,
li,
select,
input,
span,
label,
a,
h3,
button,
svg text {
	font-family: arial, tahoma, "맑은 고딕"
}

li,
select,
input,
span,
label,
a,
button,
svg text {
	font-size: 14px;
}

body {
	position: fixed; top: 0; right: 0; bottom: 0; left: 0;
	display: flex;
	flex-direction: column;
}

header img {
	float: right;
	cursor: pointer;
}

section {
	border: 1px solid #0084ff;
	margin: 10px;
}

ul {
	margin: 0;
	padding: 0;
	list-style: none;
	display: flex;
}

select {
	padding: .5em;
}

section.information li {
	flex: 1;
	min-width: 120px;
	padding: 10px;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
}

section.information ul:first-child {
	background-color: #0084ff;
	color: #fff;
}

section.information ul:first-child li {
	text-align: center;
	font-weight: bold;
}

section.select {
	padding: 10px;
}

section.select ul {
	display: flex;
}
	
section.select li {
	flex: 1;
}

section.select select {
	box-sizing: border-box;
	width: 100%;
}

nav {
	margin: 10px 10px 0 10px;
	display: flex;
	justify-content: space-between;
}

nav img {
	vertical-align: middle;
}

button.download span {
	margin-left: 10px;
}

#mode:not(.response) #mode_response,
#mode:not(.processor) #mode_processor,
#mode:not(.storage) #mode_storage,
#mode:not(.memory) #mode_memory,
#mode:not(.throughput) #mode_throughput {
	display: none;
}

/* svg */
section.chart {
	background: #fff url(../img/chart.png) no-repeat center;
	flex: 1;
	display: flex;
	flex-direction: column;
}

svg {
	flex: 1;
	width: 100%;
	height: 100%;
}

path {
	stroke: #ddd;
	stroke-width: .5;
}

#axis_left text {
	alignment-baseline: middle;
	text-anchor: end;
}

#axis_right text {
	alignment-baseline: middle;
	text-anchor: start;
}

#axis_date text {
	alignment-baseline: before-edge;
}

#end_label text {
	text-anchor: end;
}

#graph path {
	stroke: #0084ff;
	stroke-width: 2;
	fill: none;
}

body.start #start_fixed,
body.end #end_fixed,
body:not(.start) #start_move,
body:not(.end) #end_move {
	display: none;
}

		</style>
		
	</head>
	
	<body class="start end">
		
		<header>
			<img src="img/close.png" id="close">
		</header>
		
		<section class="information">
			<ul>
				<li>
					<span id="description">nameⓘ</span>
				</li>
				<li>
					<span>ip address</span>
				</li>
				<li>
					<span>type</span>
				</li>
				<li>
					<span>label</span>
				</li>
				<li>
					<span>profile</span>
				</li>
				<li>
					<span>status</span>
				</li>
				<li>
					<span>uptime</span>
				</li>
				<li>
					<span>enterprise</span>
				</li>
			</ul>
			
			<ul>
				<li>
					<span id="name">name</span>
				</li>
				<li>
					<span id="ip">ip</span>
				</li>
				<li>
					<span id="type">type</span>
				<li>
					<span id="label">label</span>
				</li>
				<li>
					<span id="profile">profile</span>
				</li>
				<li>
					<span id="status">status</span>
				</li>
				<li>
					<span id="uptime">uptime</span>
				</li>
				<li>
					<span id="enterprise">enterprise</span>
				</li>
			</ul>
		</section>
		
		<section class="select">
			<ul>
				<li>
					<label>
						<input type="radio" value="onSelectResponse" name="resource">response time
					</label>
				<li>
					<label>
						<input type="radio" value="onSelectProcessor" name="resource">processor load
					</label>
				<li>
					<label>
						<input type="radio" value="onSelectMemory" name="resource">physical memory
					</label>
				<li>
					<label>
						<input type="radio" value="onSelectStorage" name="resource">storage usage
					</label>
				<li>
					<label>
						<input type="radio" value="onSelectThroughput" name="resource">interface throughput
					</label>
					<select id="interface_list" disabled></select>
			</ul>
		</section>
		
		<nav>
			<div>
				<button class="download">
					<img src="img/download.png">
					<span>csv</span>
				</button>
				<button class="download">
					<img src="img/download.png">
					<span>png</span>
				</button>
			</div>
			<form id="mode" class="response">
				<select id="mode_response" disabled>
					<option selected>N/A
				</select>
				<select id="mode_processor">
					<option selected>mix
				</select>
				<select id="mode_storage">
					<option selected>mix
				</select>
				<select id="mode_memory" disabled>
					<option selected>N/A
				</select>
				<select id="mode_throughput">
					<option selected>mix
					<option>in
					<option>out
				</select>
			</form>
		</nav>
		
		<section class="chart">
			<svg id="chart">
				<defs>
					<clipPath id="graph_area"></clipPath>
				</defs>
				<g transform="translate(20, 20)">
			        <g transform="translate(0, -100) translate(0, 10)" id="axis_date">
			        	<g>
			        		<image xlink:href="img/draggable.png" width="16" height="16" id="start_move"></image>
			        		<image xlink:href="img/lock_gray.png" width="16" height="16" id="start_fixed"></image>
			        		<text x="20" id="start_date">start</text>
			        	</g>
			        	<g transform="translate(0, 0)" id="end_label">
			        		<text x="-20" id="end_date">end</text>
			        		<image x="-16" xlink:href="img/draggable.png" width="16" height="16" id="end_move"></image>
			        		<image x="-16" xlink:href="img/lock_gray.png" width="16" height="16" id="end_fixed"></image>
			        	</g>
			        </g>
			        <g transform="translate(0, 0) scale(1 -1)" clip-path="url(#_graph_area)" id="graph"></g>
			        <g transform="translate(0, 0)" id="axis_left"></g>
					<g transform="translate(0, 0)" id="axis_right"></g>
			        <g transform="translate(0, 0)" id="grid"></g>
			    </g>
			</svg>
		</section>
		
		<script src="js/ITAhM.js"></script>
		<script src="js/Draggable.js"></script>
		<!--script src="Chart.js"></script-->
		<script>

// 공통
var svgNS = "http://www.w3.org/2000/svg",
	xlinkNS = "http://www.w3.org/1999/xlink";

function Path(container) {
	this.initialize(container);
}

function ChartData(data) {
	this.initialize(data);
}

function ChartSummaryData(data) {
	this.initialize(data);
}

//navigation
(function (window, undefined) {
	
	var name = document.getElementById("name"),
		ip = document.getElementById("ip"),
		type = document.getElementById("type"),
		label = document.getElementById("label"),
		profile = document.getElementById("profile"),
		status = document.getElementById("status"),
		uptime = document.getElementById("uptime"),
		enterprise = document.getElementById("enterprise"),
		close = document.getElementById("close"),
		device;
	
	function initialize() {
		close.onclick = function () {
			top.closeChart();
		}
	}

	// public. 페이지의 시작, map으로부터 호출됨. 
	window.initialize = function (d, snmp) {
		initialize();
		
		device = d;
		
		name.textContent = device.name;
		ip.textContent = device.ip;
		type.textContent = device.type;
		label.textContent = device.label && (device.label.split(",")).join(", ") || "";
		profile.textContent = device.profile;
		status.textContent = snmp.timeout < 0? "up": "down";
		uptime.textContent = ITAhM.util.toUptimeString(snmp.hrSystemUptime);
		enterprise.textContent = ITAhM.util.enterpriseFromOID(snmp.sysObjectID);
		
		initThroughput(snmp);
		
		initProcessor(snmp);
		
		initStorage(snmp);
	};
	
	window.sendRequest = function (database, index, start, end, callback) {
		var request = {
				command: "query",
				ip: device.ip,
				summary: false,
				database: database,
				index: index,
				start: start,
				end: end
			};
		
		top.sendRequest(request, callback);
	};
	
	window.sendSummaryRequest = function (database, index, callback) {
		var request = {
				command: "query",
				ip: device.ip,
				summary: true,
				database: database,
				index: index
			},
			date = new Date();
		
		date.setHours(0, 0, 0, 0);
		
		request.end = date.setDate(date.getDate() +1);
		request.start = date.setFullYear(date.getFullYear() -1);
		
		top.sendRequest(request, callback);
	};
	
}) (window);

// select
(function (window, undefined) {
	
	var resources = document.getElementsByName("resource"),
		mode = document.getElementById("mode");
	
	function initialize() {
		for (var i=0, length = resources.length; i<length; i++) {
			resources[i].onchange = onSelectResource;
		}
	}
	
	function onSelectResource() {
		var method = this.value;
		
		if (method !== "onSelectThroughput") {
			onSelectThroughput(true);
		}
		
		window[method]();
	}
	
	window.setResource = function (resource) {
		mode.className = resource;
	};
	
	initialize();
	
}) (window);

// response time
(function (window, undefined) {
	
	function valueToString(value) {
		return value.toFixed(2) + "ms";
	}
	
	function onResponse(data) {
		if (!data) {
			return;
		}
		
		initChart(new ChartSummaryData(data));
	}
	
	window.onSelectResponse = function () {
		window.valueToString = valueToString;
		
		setResource("response");
		
		sendSummaryRequest("responseTime", 0, onResponse);
	};
	
}) (window);

// processor
(function (window, undefined) {
	
	var mode = document.getElementById("mode_processor");
	
	function valueToString(value) {
		return value.toFixed(2) + "%";
	}
	
	window.initProcessor = function (snmp) {
		var processor = snmp.hrProcessorIndex,
			option;
		
		for (var index in processor) {
			option = document.createElement("option");
			
			option.text = "processor."+ index;
			option.value = index;
			
			mode.add(option)
		}
	};
	
	window.onSelectProcessor = function () {
		window.valueToString = valueToString;
		
		setResource("processor");
	};
	
}) (window);

// storage
(function (window, undefined) {
	
	var mode = document.getElementById("mode_storage");
	
	function valueToString(value) {
		return ITAhM.util.toBytesString(value).replace("ytes", "");
	}
	
	window.initStorage = function (snmp) {
		var entry = snmp.hrStorageEntry,
			storage,
			option;
		
		for (var index in snmp.hrStorageIndex) {
			storage = entry[index];
			// size가 0인 것 제외. type이 non-removable storage인 것만
			if (storage.hrStorageSize > 0 && storage.hrStorageType === 4) {
				option = document.createElement("option");
				option.text = storage.hrStorageDescr;
				option.value = index;
				
				mode.add(option);
			}
		}
	};
	
	window.onSelectStorage = function () {
		window.valueToString = valueToString;
		
		setResource("storage");
	};
	
}) (window);

// memory
(function (window, undefined) {
	
	function valueToString(value) {
		return ITAhM.util.toBytesString(value).replace("ytes", "");
	}
	
	window.onSelectMemory = function () {
		window.valueToString = valueToString;
		
		setResource("memory");
	};
	
}) (window);

// throughput
(function (window, undefined) {
	
	var ifList = document.getElementById("interface_list");
	
	function valueToString(value) {
		return ITAhM.util.toBPSString(value);
	}
	
	window.initThroughput = function (snmp) {
		var ifEntry = snmp["ifEntry"],
			option, iFace;
		
		for (index in snmp["ifIndex"]) {
			iFace = ifEntry[index];
			
			option = document.createElement("option");
			option.text = iFace.ifName;
			option.title = iFace.ifDescr;
			
			ifList.appendChild(option)
		}
	};
	
	window.onSelectThroughput = function (disabled) {
		window.valueToString = valueToString;
		
		setResource("throughput");
		
		if (disabled) {
			ifList.disabled = true;
		}
		else {
			ifList.disabled = false;
		}
	};
	
}) (window);

// chart
(function (window, undefined) {
	
	var MIN_CHART_WIDTH = 100,
		MIN_CHART_HEIGHT = 100,
		MIN_AXIS_VSPACE = 50,
		MIN_AXIS_HSPACE = 160,
		MAX_AXIS_VAL_CNT = 10,
		DATE_AXIS_HEIGHT = 50,
		MARGIN = 20,
		PADDING = 5,
		WHEEL_REPEAT = 50,
		HOUR24 = 24 * 60 * 60 * 1000;
	
	function clear(svgElement) {
		var target;
		
		while(target = svgElement.firstChild) {
			svgElement.removeChild(target);
		}
	}
	
	function createText(x, y, text) {
		var svgText = document.createElementNS(svgNS, "text");
		
		svgText.setAttributeNS(null, "x", x);
		svgText.setAttributeNS(null, "y", y);
		svgText.textContent = text;
		
		return svgText;
	}
	
	// core
	(function (window, undefined) {
		var chart = document.getElementById("chart"),
			clip = document.getElementById("graph_area").appendChild(document.createElementNS(svgNS, "rect")),
			origin;
			
		var rect = {},
			initialized = false,
			resizeTimer,
			start, end, tpp, width,
			data;
		
		function initialize() {
			window.addEventListener("resize", function () {
				if (!initialized) {
					return;
				}
				
				if (resizeTimer) {
					clearTimeout(resizeTimer);
				}
				
				resizeTimer = setTimeout(onResize, 300);
			});
			
			document.addEventListener("selectstart", function (e) {
				e.preventDefault();
			});
			
			new Draggable(chart);
			
			chart.addEventListener("dragstart", function (e) {
				onDragStart(e);
			});
			
			chart.addEventListener("dragmove", function (e) {
				onDragMove(e);
			});
			
			chart.addEventListener("dragend", function (e) {
				onDragEnd(e);
			});
		}
		
		function onResize() {
			resize();
		}
		
		function resize () {
			var r = chart.getBoundingClientRect(),
				width = r.width - MARGIN *2,
				height = r.height - MARGIN *2 - DATE_AXIS_HEIGHT;
		
			//window resize 발생 했으나 chart 크기 변화는 없음
			if (width === rect.width && height === rect.height) {
				return;
			}
			
			rect = {
				width: width,
				height: height
			};
			
			// resize시 start와 end는 변함 없지만 width의 변화로 인해 tpp는 다시 계산되어야 함.
			tpp = (end - start) / width;
			
			drawGrid();
			
			drawGraph();
		}
		
		function onDragStart(e) {
		}
		
		function onDragMove(e) {
			if (!initialized) {
				return;
			}
			
			var move = tpp * e.detail.moveX,
				tmp,
				s = new Date(start).setMinutes(0, 0, 0),
				e = new Date(end).setMinutes(0, 0, 0),
				invalidate = false;
			
			if (document.body.classList.contains("start")) {
				start -= move;
				
				tmp = s;
				
				s = new Date(start).setMinutes(0, 0, 0);
				
				if (s != tmp) {
					invalidate = true;
				}
			}
			
			if (document.body.classList.contains("end")) {
				end -= move;
				
				tmp = e;
				
				e = new Date(end).setMinutes(0, 0, 0);
				
				if (e != tmp) {
					invalidate = true;
				}
			}
			
			if (invalidate) {
				data = origin.buildData(s, e);
				
				tpp = (end - start) / rect.width;
				
				writeDateLabel(start, end);
				
				drawGraph();
			}
		}
		
		function onDragEnd(e) {
		}
		
		window.buildData = function () {
			return data;
		};
		
		window.getCoordinates = function (date) {
			return {
				x: (date - start) / tpp,
				y: origin.get(date)
			}
		};
		
		window.setClipRect = function (x, y, width, height) {
			clip.setAttributeNS(null, "x", x);
			clip.setAttributeNS(null, "y", y);
			clip.setAttributeNS(null, "width", width);
			clip.setAttributeNS(null, "height", height);
		};
		
		window.getRect = function () {
			return rect;
		};
		
		// chart 초기화
		window.initChart = function (o) {
			var date = new Date();
			
			initialized = true;
			
			origin = o;
			
			// data rebuild는 최초, 시간의 변경시 발생함
			start = date.setHours(0, 0, 0, 0);
			end = date.setDate(date.getDate() +1);
			
			data = origin.buildData(start, end);
			
			resize();
			
			writeDateLabel (start, end);
		};
		
		initialize();
		
	}) (window);

	// axis
	(function (window, undefined) {
		var leftAxis = document.getElementById("axis_left"),
			rightAxis = document.getElementById("axis_right"),
			dateAxis = document.getElementById("axis_date"),
			leftAxisOffset = leftAxis.transform.baseVal.getItem(0),
			rightAxisOffset = rightAxis.transform.baseVal.getItem(0),
			dateAxisOffset = dateAxis.transform.baseVal.getItem(0),
			startDate = document.getElementById("start_date"),
			endDate = document.getElementById("end_date"),
			labelOffset = document.getElementById("end_label").transform.baseVal.getItem(0),
			data,
			startFixed = false,
			endFixed = false;
		
		function initialize() {
			document.getElementById("start_move").onclick = function () {
				document.body.classList.remove("start");
			};
			
			document.getElementById("end_move").onclick = function () {
				document.body.classList.remove("end");
			};
			
			document.getElementById("start_fixed").onclick = function () {
				document.body.classList.add("start");
			};
			
			document.getElementById("end_fixed").onclick = function () {
				document.body.classList.add("end");
			};
		}
		
		window.setDateAxis = function (width, height) {
			dateAxisOffset.setTranslate(0, height);
			labelOffset.setTranslate(width, 0);
		};
		
		window.writeDateLabel = function (start, end) {
			startDate.textContent = ITAhM.util.toDateFormatString(new Date(start));
			endDate.textContent = ITAhM.util.toDateFormatString(new Date(end));
		};
		
		window.drawAxis = function () {
			var data = buildData();
			
			clear(leftAxis);
			clear(rightAxis);
			
			if (!data) {
				return;
			}
			
			var	rect = getRect(),
				count = Math.min(MAX_AXIS_VAL_CNT, Math.round(rect.height / MIN_AXIS_VSPACE)),
				grow = (data.high - data.low) / count,
				space = rect.height / count,
				valueArray = [];
			
			for (var i=0; i<=count; i++) {
				leftAxis.appendChild(createText(0, space * i, valueToString(data.high - i * grow)));
			}
			
			rect.left = leftAxis.getBBox().width;
			leftAxisOffset.setTranslate(rect.left, 0);
			
			for (var i=0; i<=count; i++) {
				rightAxis.appendChild(createText(0, space * i, ((data.high - i * grow) / data.high *100).toFixed(2) +"%"));
			}
			
			rect.right = rightAxis.getBBox().width;
			rightAxisOffset.setTranslate(rect.width - rect.right, 0);
			
			setClipRect(rect.left + PADDING, 0, rect.width - rect.right - PADDING *2, rect.height);
		};
		
		initialize();
		
	}) (window);
	
	//graph
	(function (window, undefined) {
		var graph = document.getElementById("graph"),
			offset = graph.transform.baseVal.getItem(0),
			scale = graph.transform.baseVal.getItem(1),
			rect = getRect();
		
		window.clearGraph = function () {
			clear(graph);
		};
		
		window.drawGraph = function () {
			var data = buildData();
			
			drawAxis();
			
			clear(graph);
			
			if (!data) {
				return;
			}
			
			var	rect = getRect(),
				blocks = data.keys,
				path,
				dateArray, date, coords;
			
			graph.setAttributeNS(null, "width", rect.width);
			graph.setAttributeNS(null, "height", rect.height);
			
			offset.setTranslate(0, rect.height);
			scale.setScale(1, -1);
			
			// y좌표 : value/high * height
			// x좌표 : (date - this.start) /tpp
			path = new Path(graph);
			
			path.beginPath();
			path.moveTo(0, 0);
		
			for (var i=0, numberOfBlock=blocks.length; i<numberOfBlock; i++) {
				dateArray = blocks[i];
				
				date = dateArray[0];
				
				coords = getCoordinates(date);
				path.moveTo(coords.x, coords.y.max * rect.height / data.high);
				
				for (var j=1,numberOfDate=dateArray.length; j<numberOfDate; j++) {
					date = dateArray[j];
					
					coords = getCoordinates(date);
					
					path.lineTo(coords.x, coords.y.max * rect.height / data.high);
				}
			}
			
			path.stroke();
		};
		
	}) (window);
	
	//grid
	(function (window, undefined) {
		
		var grid, translate;
		
		function initialize() {
			grid = document.getElementById("grid");
			offset = grid.transform.baseVal.getItem(0);
		}
		
		window.drawGrid = function (count, space) {
			var rect = getRect(),
				count = Math.min(MAX_AXIS_VAL_CNT, Math.round(rect.height / MIN_AXIS_VSPACE)),
				space = rect.height / count,
				path;
			
			clear(grid);
			
			path = new Path(grid);
			
			//offset.setTranslate(rect.left, 0);
			
			for (var i=0, y; i<=count; i++) {
				y = i * space -.5;
				
				path.moveTo(0, y).lineTo(rect.width, y);
			}
			
			path.stroke();
			
			setDateAxis(rect.width, rect.height);
		};
		
		initialize();
		
	}) (window);
	
}) (window);

//Path object
(function (window, undefined) {
	
	Path.prototype = {
		initialize: function (container) {
			this.container = container;
			this.path = document.createElementNS(svgNS, "path");
			
			container.appendChild(this.path);
			
			this.beginPath();
		},
		
		moveTo: function (x, y) {
			this.distance[this.distance.length] = "M"+ x +" "+ y;
			
			return this;
		},
		
		lineTo: function (x, y) {
			this.distance[this.distance.length] = "L"+ x +" "+ y;
			
			return this;
		},
		
		stroke: function () {
			this.path.setAttributeNS(null, "d", this.distance.join(" "));
			this.path.setAttributeNS(null, "stroke", this.strokeStyle || "#000000");
		},
		
		fill: function () {
			this.path.setAttributeNS(null, "d", this.distance.join(" "));
			this.path.setAttributeNS(null, "fill", this.fillStyle || "#000000");
		},
		
		beginPath: function () {
			this.distance = [];
		},
		
		closePath: function () {
			this.distance[this.distance.length] = "Z"
		}
	};
	
}) (window);

//ChartData object
(function (window, undefined) {
	
	ChartData.prototype = {
		initialize: function (data) {
			this.data = data;
		},
		
		next: function (date) {
			return date.setMinutes(date.getMinutes() +1, 0, 0);
		},
		
		buildData: function (start, end, unit) {
			var keys = [],
				tmp = [],
				date = new Date(start),
				value, high, low;
			
			date.setSeconds(0, 0);
			
			do {
				value = this.data[mills];
				
				if (value) {
					tmp[tmp.length] = mills;
					
					high = Math.max(value, high || value);
					low = Math.min(value, low || value);
				}
				else if (tmp.length > 0) {
					data[data.length] = tmp;
					
					tmp = [];
				}
			} while (this.next(date) < end);
			
			if (tmp.length > 0) {
				data[data.length] = tmp;
			}
			
			return keys.length > 0? {
				high: high,
				low: low,
				keys: keys
			}: undefined;
		}
		
	};
	
}) (window);

(function (window, undefined) {
	
	ChartSummaryData.prototype = {
		initialize: function (data) {
			this.data = data;
		},
		
		next: function (date) {
			return date.setHours(date.getHours() +1, 0, 0, 0);
		},
		
		buildData: function (start, end) {
			var keys = [],
				tmp = [],
				date = new Date(start),
				mills, value, high, low;
			
			mills = date.setMinutes(0, 0, 0);
			
			do {
				value = this.data[mills];
				
				if (value) {
					tmp[tmp.length] = mills;
					
					high = Math.max(value.max, high || value.max);
					low = Math.min(value.min, low || value.min);
				}
				else if (tmp.length > 0) {
					keys[keys.length] = tmp;
					
					tmp = [];
				}
			}
			while ((mills = this.next(date)) < end);
			
			if (tmp.length > 0) {
				keys[keys.length] = tmp;
			}
			
			if (high === low) {
				high++;
				low--;
			}
			
			return keys.length > 0? {
				high: high,
				low: low,
				keys: keys
			}: undefined;
		},
		
		get: function (date) {
			return this.data[date];
		}
	};
	
}) (window);

(function (window, undefined) {}) (window);

		</script>
	
	</body>
	
</html>