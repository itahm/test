<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="Content-Script-Type" content="text/javascript">
		<meta http-equiv="Content-Style-Type" content="text/css">
		<title>ITAhM::Map</title>
		<link rel="stylesheet" href ="frame.css ">
		<style>

body {
	font-family: arial, tahoma, "맑은 고딕";
	position: fixed; top: 0; right: 0; bottom: 0; left: 0;
	/*display: flex;*/
}

div,
input,
select,
span,
button {
	font-size: 12px;
}

aside {
	position: fixed; top: 0; bottom: 0; left: 0; width: 199px;
	border-right: 1px solid #0084ff;
	padding: 10px;
	box-sizing: border-box;
	background-color: #fff;
}

section {
	position: fixed; top: 0; right: 0; bottom: 0; left: 0;
}

aside input[type=button] {
	padding: .5em;
}

form {z-index: 9;
}
.peer {
	margin: 0 0 10px 0;
}

.title {
	border-radius: 5px 5px 0 0;
	background-color: #0084ff;
	color: #ddf;
	border: 1px solid #88f;
	border-bottom: 0;
	padding: 5px;
}

.body {
	border: 1px solid #88f;
	border-top: 0;
	padding: 5px;
	position: relative;
	min-height: 20px;
}

.body input,
.body select {
	padding: 5px;
	box-sizing: border-box;
	width: 100%;
}

.body a {
	position: absolute;
	top: 10px;
	right: 10px;
	cursor: pointer;
}

.body li {
	cursor: pointer;
}

.body li:hover:after {
	content: "x";
	float: right;
}

.body:not(.selected) :not(first-child),
.body:not(.snmp) .snmp,
.body.snmp .nosnmp,
body:not(.link) aside {
	display: none;
}

input[disabled] {
	background-color: transparent;
	border: 0;
}

.hide {
	display: none;
}

#menu {
	position: absolute; top: 0; left: 0;
	width: 100px;
}

#menu button {
	padding: 5px 5px 5px 21px ;
	display: block;
	width: 100%;
	text-align: center;
}

#menu_name {
	height: 20px;
	line-height: 20px;
	padding: 5px;
	border-radius: 5px 5px 0 0;
	background-color: #0084ff;
	color: #ddf;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
}

#menu_link {
	background: #fff url("img/link.png") no-repeat 5px center;
}

#menu_select {
	background: #fff url("img/select.png") no-repeat 5px center;
}

		</style>
	
		<script src="js/Draggable.js"></script>
		<script src="js/Canvas.js"></script>
			
	</head>
	
	<body>
	
		<section id="map"></section>
		
		<aside>
			<form id="form">
				<div class="peer">
					<div class="title">peer1</div>
					<div class="body" id="peer1">
						<input id="peer1_name" disabled>
						<a id="peer1_reset">x</a>
						<div class="nosnmp">
							<input id="peer1_ifname" type="text" placeholder="interface name">
							<ul id="peer1_iflink"></ul>
						</div>
						<select id="peer1_iflist" class="snmp">
							<option value="" selected>select interface
						</select>
					</div>
				</div>
				<div class="peer">
					<div class="title">peer2</div>
					<div class="body" id="peer2">
						<input id="peer2_name" disabled>
						<a id="peer2_reset">x</a>
						<div class="nosnmp">
							<input id="peer2_ifname" type="text" placeholder="interface name">
							<ul id="peer2_iflink"></ul>
						</div>
						<select id="peer2_iflist" class="snmp">
							<option value="" selected>select interface
						</select>
					</div>
				</div>
			</form>
			<input type="button" value="link" id="link">
			<input type="button" value="cancel" id="cancel">
		</aside>
		
		<div class="hide">
			<div id="menu">
				<div id="menu_name"></div>
				<button id="menu_link">link</button>
				<button id="menu_select">select</button>
			</div>
		</div>
		
		<script>	

		function allowDrag(e) {
			e.preventDefault();
			
		}
		
(function (window, top) {
	
	if (window === top) {
		throw "";
	}
	
	var elements = {
			map: document.getElementById("map"),
			form: document.getElementById("form"),
			show: document.getElementById("show"),
			link: document.getElementById("link"),
			cancel: document.getElementById("cancel"),
			menu: {
				balloon: document.getElementById("menu"),
				name: document.getElementById("menu_name"),
				link: document.getElementById("menu_link"),
				select: document.getElementById("menu_select")
			},
			peer1: {
				body: document.getElementById("peer1"),
				name: document.getElementById("peer1_name"),
				ifName: document.getElementById("peer1_ifname"),
				ifList: document.getElementById("peer1_iflist"),
				ifLink: document.getElementById("peer1_iflink"),
				reset: document.getElementById("peer1_reset")
			},
			peer2: {
				body: document.getElementById("peer2"),
				name: document.getElementById("peer2_name"),
				ifName: document.getElementById("peer2_ifname"),
				ifList: document.getElementById("peer2_iflist"),
				ifLink: document.getElementById("peer2_iflink"),
				reset: document.getElementById("peer2_reset")
			}
		},
		canvas = new Canvas(elements.map),
		menu = new Menu(elements.map, elements.menu.balloon),
		layer = {
			line: canvas.add(),
			device: canvas.add()
		},
		deviceList = top.getDeviceList(),
		iconMap = top.getIconMap(),
		isDragging = false;
	
	/** event */
	elements.map.addEventListener("mousedown", onHideMenu, false);
	//elements.map.addEventListener("mouseout", menu.hide, false);
	elements.menu.link.addEventListener("click", onSelectPeer, false);
	elements.menu.select.addEventListener("click", onSelectDevice, false);
	elements.menu.balloon.addEventListener("mousedown", onStopPropagation, false);
	elements.menu.balloon.addEventListener("click", menu.hide, false);
	elements.link.addEventListener("click", onLink, false);
	elements.cancel.addEventListener("click", onCancel, false);
	elements.peer1.reset.addEventListener("click", resetPeer.bind(undefined, elements.peer1), false);
	elements.peer2.reset.addEventListener("click", resetPeer.bind(undefined, elements.peer2), false);
	
	/** test 
	document.getElementById("test").addEventListener("click", function () {
		window.open().document.write(JSON.stringify(deviceList));
	}, false);
	*/
	
	canvas.ondragstart = onDragStart;
	canvas.ondragmove = onDragMove;
	canvas.ondragend = onDragEnd;
	//canvas.onselect = onSelect;
	canvas.onenter = onEnter;
	canvas.onleave;
	canvas.ondragstart;
	
	layer.device.ondraw = onDrawDevice;
	layer.line.ondraw = onDrawLine;
	
	/** constructor */
	(function () {		
		var device;
		
		for (var id in deviceList) {
			device = deviceList[id];
			
			layer.device.add(device);
			layer.line.add(device);
		}
		
		(function (context) {
			context.font = "12px arial, tahoma, '맑은 고딕'";
			context.textBaseline = "top";
			context.textAlign = "center";
		}) (layer.device.context);
		
		(function (context) {
			context.font = "12px arial, tahoma, '맑은 고딕'";
			context.textBaseline = "top";
			context.textAlign = "center";
			context.lineWidth = .5;
			context.strokeStyle = "#888";
		}) (layer.line.context);
		
		
		layer.device.invalidate();
		layer.line.invalidate();
		
		canvas.invalidate();
	}) ();
	
	/**
	 * callback
	 */
	
	function onDrawDevice(context, hitContext, device) {
		var icon = iconMap[device.type],
			width = icon.width,
			height = icon.height,
			x, y;
		
		if (device.x === undefined || device.y === undefined) {
			return;
		}
		
		x = Math.round(width /2);
		y = Math.round(height /2);
		
		context.drawImage(icon, device.x - x, device.y - y, width, height);
		context.fillText(device.name, device.x, device.y + y);
		
		hitContext.fillRect(device.x - x, device.y - y, width, height);
	}
	

	function onDrawLine(context, hitContext, device) {
		var iFace = device.iFace,
			peer;		
		
		for (var ifName in iFace) {
			peer = deviceList[iFace[ifName]];
			
			context.beginPath();
			context.moveTo(device.x, device.y);
			context.lineTo(peer.x, peer.y);
			context.stroke();
			
			context.fillText(ifName, (device.x *2 + peer.x) /3, (device.y *2 + peer.y) /3);
		}
	}
	
	function onDragStart() {
		isDragging = true;
	}
	
	function onDragMove(e) {
		if (e.node) {
			e.node.data.x += e.moveX;
			e.node.data.y += e.moveY;
			
			e.node.layer.invalidate();
			layer.line.invalidate();
			
			canvas.invalidate();
		}
		else {
			canvas.translate(e.dragX, e.dragY);
		}
	}
	
	function onDragEnd(e) {//console.log("drag end");
		isDragging = false;
		
		if (e.node) {
			return;
		}
		else {
			moveMap(e.dragX, e.dragY);
			
			layer.device.invalidate();
			layer.line.invalidate();
			
			canvas.invalidate();
		}
	}
	
	function onLink() {
		var ifName1 = getIFName(elements.peer1),
			ifName2 = getIFName(elements.peer2);
		
		if (!ifName1 || !ifName2) {
			return;
		}
		
		elements.peer1.device.iFace[ifName1] = elements.peer2.device.id;
		elements.peer2.device.iFace[ifName2] = elements.peer1.device.id;
		
		layer.line.invalidate();
		
		canvas.invalidate();
		
		hideDialog();
	}
	
	function onCancel() {
		hideDialog();
	}
	
	function onEnter(node) {
		if (isDragging) {//console.log("ignore");
			return;
		}
		
		elements.menu.name.textContent = node.data.name;
		
		menu.node = node;
		menu.show();
	}
	
	function onHideMenu(e) {//console.log(e.button);
		if (e.button !== 0) {
			e.preventDefault();
		}
		else {
			menu.hide();
		}
	}
	
	function onSelectPeer() {
		var device = menu.node.data
			, peer;
		
		/** 이미 link 모드 이면 empty peer */
		if (document.body.classList.contains("link")) {
			if (!elements.peer1.device) {
				/** 중복 */
				if (elements.peer2.device === device) {
					return;
				}
				
				peer = elements.peer1;
			}
			else if (!elements.peer2.device) {
				/** 중복 */
				if (elements.peer1.device === device) {
					return;
				}
				
				peer = elements.peer2;
			}
			else {
				return;
			}
		}
		
		/** link모드가 아니었다면 항상 peer1 */
		else {
			peer = elements.peer1;
			
			document.body.classList.add("link");
		}
		
		peer.device = device;
		peer.name.value = device.name;
		peer.body.classList.add("selected");
		
		if (device.snmp) {
			peer.body.classList.add("snmp");
			
			var list = peer.ifList,
				iFace = device.iFace,
				option;
			
			for (var name in iFace) {
				option = document.createElement("optioin");
				option.text = name;
				
				list.add(option);
			}
		}
		else {
			peer.body.classList.remove("snmp");
			
			var list = peer.ifLink,
				iFace = device.iFace,
				li;
			
			for (var name in iFace) {
				li = document.createElement("li");
				li.textContent = name;
				li.onclick = onRemoveLink.bind(li, device, name);
				list.appendChild(li);
			}
		}
	}
	
	function onSelectDevice() {
		top.getFrame("device").resetDevice(menu.node.data.id);
		
		top.minimize();
	}
	
	function onRemoveLink(device, name) {
		if (!confirm("remove selected link?")) {
			return;
		}
		
		var iFace = device.iFace;
		
		this.parentNode.removeChild(this);
		
		(function (iFace) {
			for (var name in iFace) {
				if (iFace[name] == device.id) {
					delete iFace[name];
				}
			}
		}) (deviceList[iFace[name]].iFace);
		
		delete iFace[name];
		
		layer.line.invalidate();
		
		canvas.invalidate();
	}
	
	function onStopPropagation(e) {
		e.stopPropagation();
	}
	
	/**
	 * method
	 */
	
	function hideDialog() {
		resetPeer(elements.peer1);
		resetPeer(elements.peer2);
		
		elements.form.reset();
		
		document.body.classList.remove("link");
	}
	
	function resetPeer(peer) {
		peer.name.value = "";
		peer.device = undefined;
		
		var child;
		while (child = peer.ifLink.firstChild) {
			peer.ifLink.removeChild(child);
		}
		
		peer.body.classList.remove("selected");
	}
	
	function getIFName(peer) {
		var device = peer.device,
			ifName;
		
		if (!device) {
			return;
		}
		
		/** interface가 입력되거나 선택 되지 않은 경우 취소 */
		ifName = device.snmp? peer.ifList.value: peer.ifName.value;
		if (!ifName) {
			return;
		}
		
		/** 이미 link에 사용된 interface name 입력시 취소 */
		if (ifName in device.iFace) {
			alert("interface name is already in use");
			
			return ;
		}

		return ifName;
	}
	
	function moveMap(x, y) {
		var device;
		
		for (var id in deviceList) {
			device = deviceList[id];
			
			device.x += x;
			device.y += y;
		}
	}
	
	function setPeer() {
		
	}
		
	/** inner class */
	function Menu(container, balloon) {
		var menu = this,
			fragment = document.createDocumentFragment(),
			x, y, cX, cY;
		
		container.addEventListener("mousemove", function (e) {
			var rect = container.getBoundingClientRect();
			
			x = e.clientX - rect.left;
			y = e.clientY - rect.top;
			cX = rect.width /2;
			cY = rect.height /2;
		}, false);
		
		fragment.appendChild(balloon);
		
		this.show = function () {
			var rect,
				offset = 5;
			
			container.appendChild(balloon);
			
			rect = balloon.getBoundingClientRect();
			
			if (x < cX) {
				x += offset;
			}
			else {
				x -= (rect.width + offset);
			}
			
			if (y < cY) {
				y += offset;
			}
			else {
				y -= (rect.height + offset);
			}
			
			balloon.style.top = y +"px";
			balloon.style.left = x +"px";
			
			
		};
		
		this.hide = function () {
			fragment.appendChild(balloon);
		};
	}
	

	/**
	 * public method
	 */ 
	window.selectDevice = function (id) {
		var device = deviceList[id];
		
		moveMap(-device.x, -device.y);
		
		layer.device.invalidate();
		layer.line.invalidate();
		
		canvas.invalidate();
	};
	
	window.reload = function () {
		document.location.reload();
	};
	
}) (window, top);

		</script>
	
	</body>
	
</html>