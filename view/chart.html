<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="Content-Script-Type" content="text/javascript">
		<meta http-equiv="Content-Style-Type" content="text/css">
		<title>ITAhM::Device</title>
		
		<style>
body,
li,
select,
input,
span,
label,
a,
h3 {
	font-family: arial, tahoma, "맑은 고딕"
}

li,
select,
input,
span,
label,
a {
	font-size: 12px;
}

aside {
	position: fixed; top: 0; bottom: 0; left: 0; width: 300px;
	box-sizing: border-box;
	padding: 10px;
	overflow-y: scroll;
}

section {
	position: fixed; top: 0; right: 0px; bottom: 0; left: 300px;
	box-sizing: border-box;
	padding: 10px;
	background: #fff url(../img/chart.png) no-repeat center;
}

input[type="button"],
button {
	padding: .5em;
}

.table ul {
	list-style: none;
	padding: 0;
	margin: 0;
	display: flex;
	border-bottom: 1px solid #ddd;
}

.table ul:first-child {
	border-top: 1px solid #ddd;
}

.table li {
	flex: 2;
}

.table li:first-child {
	flex: 1;
	text-align: right;
	background-color: #0084ff;
	color: #ddf;
	font-weight: bold;
}

.table li >* {
	display: block;
	padding: .5em;
}

.table input[type=text],
.table select {
	box-sizing: border-box;
	width: 100%;
}

#controller #offline,
#controller.realtime .right,
#controller.realtime .left :not(#offline),
#controller:not(.copied) #paste,
.hidden {
	display: none;
}

li {
	margin: 0;
	vertical-align: bottom;
}

/** chart */

#chart {
	display: flex;
	flex-direction: column;
}

#chart> .chart {
	-webkit-flex: 1;
	flex: 1;
	height: 0;
	position: relative;
}
		
#controller {
	position: absolute; top: 5px; right: 10px; left: 0;
}

#controller > div.right {
	float: right;
}

#controller > div.left {
	float: left;
}

#controller.realtime #offline {
	display: inline;
}

img {
	vertical-align: middle;
	border: 1px solid transparent;
}

img.button:hover {
	border-color: #ddf;
	cursor: pointer;
}

#controller a {
	font-weight: bold;
}

#controller a:hover {
	color: #73a4e6;
	text-decoration: underline;
	cursor: pointer;
}

#selector {
	position: absolute; top: 5px; left: 0;
}

#description {
	cursor: default;
}

#description:hover {
	text-decoration: underline;
}

/*
nav.button {
	position: fixed; top: 10px; right: 10px;
}

body.detached nav.button {
	display: none;
}

*/

		</style>
		
	</head>
	
	<body>
		
		<aside>
			<h3>device information<button id="edit" style="float:right">edit</button></h3>
			<div class="table information">
				<div id="information">
					<ul>
						<li>
							<span id="description">nameⓘ</span>
						<li>
							<span id="name"></span>
					</ul>
					<ul>
						<li>
							<span>ip address</span>
						<li>
							<span id="ip"></span>
					</ul>
					<ul>
						<li>
							<span>type</span>
						<li>
							<span id="type"></span>
					</ul>
					<ul>
						<li>
							<span>label</span>
						<li>
							<span id="label"></span>
					</ul>
					<ul>
						<li>
							<span>profile</span>
						<li>
							<span id="profile"></span>
					</ul>
					<ul>
						<li>
							<span>status</span>
						<li>
							<span id="status"></span>
					</ul>
					<ul>
						<li>
							<span>uptime</span>
						<li>
							<span id="uptime"></span>
					</ul>
					<ul>
						<li>
							<span>enterprise</span>
						<li>
							<span id="enterprise"></span>
					</ul>
				</div>
				
			</div>
			
			<div>
				<h3>
					snmp response time
				</h3>
				<ul>
					<li><input type="checkbox" id="response">response time (ms)
				</ul>
				
				<h3>
					processor load
				</h3>
				<ul id="processor"></ul>
			
				<h3>
					physical memory
				</h3>
				<ul id="memory"></ul>
				
				<h3>
					storage usage
				</h3>
				<ul id="storage"></ul>
				
				<h3>
					interface throughput
				</h3>
				<ul id="interface"></ul>
			</div>
		</aside>
		
		<section id="chart"></section>
		
		<!--nav class="button">
			<a id="detach" title="open new window"><img src="../img/stick.png"></a>
			<a id="close" title="close window"><img src="../img/close.png"></a>
		</nav-->
		
		<div class="hidden">
			<div id="controller">
				<div class="right">
					<img src="../img/download.png" width="16px" height="16px">
					<a id="csv" title="download chart data as chart.csv">csv</a>
					<a id="png" title="download chart image as chart.png">png</a>
				</div>
				<div class="left">
					<img src="../img/chart.png" id="offline" width="16px" height="16px" title="offline chart" class="button">
					<div>
						<img src="../img/realtime.png" id="realtime" width="16px" height="16px" title="realtime chart" class="button">
						<!--img src="../img/detail.png" id="detail" width="16px" height="16px" title="detailed chart" class="button"-->
						<img src="../img/copy.png" id="copy" width="16px" height="16px" title="copy date range" class="button">
						<img src="../img/paste.png" id="paste" width="16px" height="16px" title="paste date range" class="button">
						<!-- img src="../img/paste_g.png" width="16px" height="16px" title="empty"-->
						<img src="../img/calendar.png" id="apply" width="16px" height="16px" title="apply date range" class="button">
						<label>
							from
							<input type="date" id="start">
						</label>
						<label>
							to
							<input type="date" id="end">
						</label>
					</div>
				</div>
			</div>
			<div id="selector">
				<img src="../img/select.png" width="16px" height="16px" title="select chart" class="button">
			</div>
		</div>
		
		<script src="../js/ITAhM.js"></script>
		<script src="../js/Draggable.js"></script>
		<script src="../js/ChartObject.js"></script>
		<script src="../js/Chart.js"></script>
		<script>

if (!opener) throw "";

(function (window, undefined) {
	var elements = {
			chart: document.getElementById("chart"),
			aside: document.querySelector("aside"),
			name: document.getElementById("name"),
			ip: document.getElementById("ip"),
			type: document.getElementById("type"),
			label: document.getElementById("label"),
			profile: document.getElementById("profile"),
			status: document.getElementById("status"),
			uptime: document.getElementById("uptime"),
			description: document.getElementById("description"),
			enterprise: document.getElementById("enterprise"),
			information: document.getElementById("information"),
			resource: {
				processor: document.getElementById("processor"),
				memory: document.getElementById("memory"),
				storage: document.getElementById("storage"),
				"interface": document.getElementById("interface"),
			}
		},
		device;
	
	/**
	 * 초기화
	 */
	initEvent();
	
	initDevice();
	
	/**
	 * callback method
	 */
	function onResponse(request, chart, response, status) {
		if (status === 200) {
			if (request.summary) {
				chart.data = response;
			
				chart.invalidate();
			}
			else {
				chart.showDetail(response);
			}
		}
		else if (status === 401) {
			opener.unauthorized();
		}
		else {console.log(request, response);
			throw status;
		}
	}
	
	/**
	 * monitor하고자 하는 resource check시 chart에 추가하거나 삭제
	 */
	function onCheckResource(chartData, e) {
		var checkbox = e.currentTarget;
		
		if (!checkbox.checked) {
			chartData.chart.close();
			
			// realtime mode 이었다면 listener에서 제거해 줘야 한다.
			stopListening(chartData.chart);
			
			chartData.chart = undefined;
		}
		else {
			var chart = new Chart(elements.chart),
				date = new Date(),
				request = {
					command: "query",
					ip: device.ip,
					database: chartData.database,
					index: chartData.index,
					summary: true,
					end: date.setMinutes(0, 0, 0),
					start: date.setFullYear(date.getFullYear() -1)
					
				};
			
			chart.setData(chartData);
			
			setControllerEvent(chart);
			
			chart.ondetail = onDetail.bind(undefined, chart);
			
			opener.sendRequest(request, onResponse.bind(undefined, request, chartData.chart = chart));
		}
		
		resize();
	}
	
	function onDetail(chart, start, end) {
		var charData = chart.getData(),
			request = {
			command: "query",
			ip: device.ip,
			database: charData.database,
			index: charData.index,
			summary: false
		},
		startDate = new Date(chart.start),
		endDate = new Date(chart.end);
		
		endDate.setSeconds(0, 0);
		
		request.start = startDate.setSeconds(0, 0);
		request.end = endDate.setMinutes(endDate.getMinutes() +1);
		
		opener.sendRequest(request, onResponse.bind(undefined, request, chart));
	}
	
	/**
	 * private method
	 */
	function initEvent() {
		document.getElementById("edit").addEventListener("click", onEdit, false);
	}
	
	function initDevice() {
		device = opener.getDeviceData()[window.name];
		
		elements.name.textContent = device.name;
		elements.ip.textContent = device.ip;
		elements.type.textContent = device.type;
		elements.label.textContent = device.label && (device.label.split(",")).join(", ") || "";
		elements.profile.textContent = device.profile;
		
		opener.sendRequest({
			command: "select",
			ip: device.ip
		}, onSNMP);
	}
	
	function onEdit() {
		opener.showDialog("dialog/device.html");
	}
	
	function onSNMP(snmp, status) {
		if (status === 200) {
			elements.description.title = snmp.sysDescr;
			elements.status.textContent = snmp.timeout < 0? "up": "down";
			elements.uptime.textContent = ITAhM.util.toUptimeString(snmp.hrSystemUptime);
			elements.enterprise.textContent = ITAhM.util.enterpriseFromOID(snmp.sysObjectID);
			
			for (var resource in resetResource) {
				resetResource[resource](snmp);
			}

		}
		else if (status === 401) {
			opener.unauthorized();
		}
		else if (status === 400){
			console.log(response.error);
		}
		else {
			throw status;
		}
	}
		
	var resetResource = {
		"response": function (snmp) {
			var checkbox, resource, li, chartData;
			
			checkbox = document.getElementById("response");
			chartData = {
				title: "response time",
				capacity: 3000,
				onyvalue: function (value) {
					return value.toFixed(2) +"ms";
				},
				update: function (response) {
					return response.responseTime;
				},
				database: "responseTime",
				index: 0
			};
			
			checkbox.addEventListener("click", onCheckResource.bind(undefined, chartData), false);
		},
		"processor": function (snmp) {
			var checkbox, resource, li, chartData;
			
			for (index in snmp.hrProcessorIndex) {
				checkbox = document.createElement("input");
				
				chartData = {
					title: "processor load",
					capacity: 100,
					onyvalue: function (value) {
						return value.toFixed(2) +"%";
					},
					update: function (response, index) {
						return response.hrProcessorEntry[index];
					},
					database: "hrProcessorLoad",
					index: index
				};
				
				checkbox.addEventListener("click", onCheckResource.bind(undefined, chartData), false);
				
				li = document.createElement("li");
				li.appendChild(checkbox).type = "checkbox";
				li.appendChild(document.createElement("span")).textContent = "index."+ index;
				
				elements.resource.processor.appendChild(li);
			}
		},
		"storage": function (snmp, oncreated) {
			var checkbox, resource, li, chartData;
			
			for (index in snmp["hrStorageIndex"]) {
				resource = snmp["hrStorageEntry"][index];
				
				if (resource["hrStorageSize"] === 0) {
					continue;
				}
				
				li = document.createElement("li");
				checkbox = document.createElement("input");
				li.appendChild(checkbox).type = "checkbox";
				
				chartData = {
					capacity: resource.hrStorageSize * resource.hrStorageAllocationUnits,
					onyvalue: function (value) {
						return ITAhM.util.toBytesString(value).replace("ytes", "");
					},
					update: function (response, index) {
						var resource = response.hrStorageEntry[index];
						
						return resource.hrStorageUsed * resource.hrStorageAllocationUnits;
					},
					database: "hrStorageUsed",
					index: index
				};
				
				// physical memory
				if (resource["hrStorageType"] === 2) {				
					li.appendChild(document.createElement("span")).textContent = "index."+ index;
					
					chartData.title = "physical memory";
					
					elements.resource.memory.appendChild(li);
				}
				
				// non-removable storage
				else if (resource["hrStorageType"] === 4) {
					li.appendChild(document.createElement("span")).textContent = resource["hrStorageDescr"];
					
					chartData.title = "storage usage";
					
					elements.resource.storage.appendChild(li);
				}

				
				
				checkbox.addEventListener("click", onCheckResource.bind(undefined, chartData), false);
			}
		},
		"throughput": function (snmp) {
			var checkbox, resource, li, chart;
			
			for (index in snmp["ifIndex"]) {
				resource = snmp["ifEntry"][index];
				
				checkbox = document.createElement("input");
				
				li = document.createElement("li");
				li.title = resource["ifDescr"];
				li.appendChild(checkbox).type = "checkbox";
				li.appendChild(document.createElement("span")).textContent = resource["ifName"];
				
				chartData = {
					title: "interface throughput input",
					capacity: resource["ifSpeed"],
					onyvalue: function (value) {
						return ITAhM.util.toBPSString(value);
					},
					update: function (response, index) {
						return response.ifEntry[index].ifInOctets;
					},
					database: "ifInOctets",
					index: index
				};
				
				checkbox.addEventListener("click", onCheckResource.bind(undefined, chartData), false);
				
				chartData = {
					title: "interface throughput output",
					capacity: resource["ifSpeed"],
					onyvalue: function (value) {
						return ITAhM.util.toBPSString(value);
					},
					update: function (response, index) {
						return response.ifEntry[index].ifOutOctets;
					},
					database: "ifOutOctets",
					index: index
				};
				
				checkbox.addEventListener("click", onCheckResource.bind(undefined, chartData), false);
				
				elements.resource["interface"].appendChild(li);
			}
		},
	};
	
	function resize() {
		ITAhM.util.fireEvent("resize", window);
	}
	
	function stopPropagation(e) {
		e.stopPropagation();
	}
	 
	/**
	 * public method
	 */
	
})(window);

/**
 * resource
 */
(function (window, undefined) {
	
})(window);

/**
 * controller
 */
(function (window, undefined) {
	var selectedChart, focusedChart, copiedStartMills, copiedEndMills,
		controller = document.getElementById("controller"),
		start = document.getElementById("start"),
		end = document.getElementById("end"),
		offline = document.getElementById("offline"),
		realtime = document.getElementById("realtime"),
		selector = document.getElementById("selector"),
		fragment = document.createDocumentFragment(),
		timer, listener = [];
	
	/**
	 * 초기화
	 */
	initEvent();
	
	start.value = end.value = ITAhM.util.toDateString(new Date());
	
	/**
	 * callback method
	 */
	function onSelectChart(e) {
		selectedChart = focusedChart;
		
		fragment.appendChild(selector);
		
		selectedChart.append(controller);
		
		controller.classList[selectedChart.mode === "realtime"? "add": "remove"]("realtime");
	}
	
	function onOffline(e) {

		controller.classList.remove("realtime");
		
		selectedChart.setMode("offline");
		
		stopListening(selectedChart);
	}
	
	function onOnline(e) {
		controller.classList.add("realtime");
		
		selectedChart.setMode("realtime");
		
		if (timer === undefined) {
			timer = setInterval(update, 1000);
		}
		
		listener[listener.length] = selectedChart;
	}
	
	function onApply(e) {
		var startMills = Date.parse(start.value),
			endMills = Date.parse(end.value);
		 
		endDate = new Date(endMills);
		
		// locale에 따라 국가별 hour는 달라지므로 별도로 0으로 채워주어야 함.
		endDate.setHours(0);
		
		// start는 해당 일자의 0시로, end는 해당 일자의 24시(다음날의 0시)로 설정.
		selectedChart.setDate(new Date(startMills).setHours(0), endDate.setDate(endDate.getDate() +1));
		
		onChangeDate(selectedChart);
	}
	
	function onCopyRange(e) {
		controller.classList.add("copied");
		
		copiedStartMills = selectedChart.start;
		copiedEndMills = selectedChart.end;
		
	}
	
	function onPasteRange(e) {
		selectedChart.setDate(copiedStartMills, copiedEndMills);
	}
	
	function onFocusChart(chart) {
		fragment.appendChild(selector);
		
		if (chart === selectedChart) {
			return;
		}
		
		chart.append(selector);
		
		focusedChart = chart;
	}
	
	function onChangeDate(chart) {
		if (chart !== selectedChart) {
			return;
		}
		
		start.value = ITAhM.util.toDateString(new Date(chart.start));
		end.value = ITAhM.util.toDateString(new Date(chart.end));
	}
	
	function onCapture() {
		selectedChart.capture();
	}
	
	function onDownload() {
		selectedChart.download();
	}
	
	function onUpdate(response, status) {
		if (status === 200) {
			var currentMills = new Date().getTime(),
				chart, chartData;
			
			for (var i=0, length=listener.length; i<length; i++) {
				chart = listener[i];
				chartData = chart.getData();
				
				chart.update(currentMills, chartData.update(response, chartData.index));
			}
		}
		else if (status === 401) {
			opener.unauthorized();
		}
		else if (status === 400){
			throw response.error;
		}
		else {
			throw status;
		}
	}
	
	/**
	 * private method
	 */
	function initEvent() {
		//controller.addEventListener("mousedown", stopPropagation, false);
		selector.addEventListener("click", onSelectChart, false);
		document.getElementById("png").addEventListener("click", onCapture, false);
		document.getElementById("csv").addEventListener("click", onDownload, false);
		offline.addEventListener("click", onOffline, false);
		realtime.addEventListener("click", onOnline, false);
		document.getElementById("apply").addEventListener("click", onApply, false);
		document.getElementById("copy").addEventListener("click", onCopyRange, false);
		document.getElementById("paste").addEventListener("click", onPasteRange, false);
	}
	
	function update() {
		opener.sendRequest({
			command: "select",
			ip: device.ip,
			trigger: true
		}, onUpdate, true);
	}

	/**
	 * public method
	 */
	 window.setControllerEvent = function (chart) {
		chart.on("mouseover", onFocusChart.bind(undefined, chart));
		chart.onchange = onChangeDate.bind(undefined, chart);
	}
	
	// chart가 realtime mode 였다면 listenr 목록에서 제거
	window.stopListening = function (chart) {
		var index = listener.indexOf(chart);
		
		listener.splice(index, 1);
		
		if (listener.length === 0) {
			clearInterval(timer);
			
			timer = undefined;
		}
	};

})(window);

/**
 * navigation
 */
 /*
(function (window, undefined) {
	initEvent();
	
	function initEvent() {
		document.getElementById("close").addEventListener("click", onClose, false);
		document.getElementById("detach").addEventListener("click", onDetach, false); 
	}
	
	
	// callback method
	function onClose() {
		top.selectDevice();
		
		top.closeView();
	}
	
	function onDetach() {
		top.showThread("chart.html");
		
		top.
	}
	
})(window);
*/
		</script>
	
	</body>
	
</html>